// match prev_active_r{
                        //     0 =>{//First piece in row 
                        //         if (row[j] == Some(&Piece::Attacker)) == turn_parity {
                        //             //Generate moves going left only
                        //             for magnitude in 1..=none_count_r {
                        //                 moves.push(MoveRequest{magnitude: magnitude, direction: Direction::L, position: (j + (game.sizen * i))});
                        //             }
                        //             none_count_r = 0;
                        //             prev_active_r = 1;
                        //         } else {
                        //             //First piece is not ours, no moves to add
                        //             prev_active_r = 2;
                        //         }
                        //     none_count_r = 0;
                        //     }
                        //     1 =>{//Prior piece was active player, moves right valid
                        //         for magnitude in 1..=none_count_r {
                        //             moves.push(MoveRequest{magnitude: magnitude, direction: Direction::R, position: (j - none_count_r - 1 + (game.sizen * i))});
                        //         }
                        //         if (row[j] == Some(&Piece::Attacker)) == turn_parity {//Left moves also valid
                        //             for magnitude in i..=none_count_r {
                        //                 moves.push(MoveRequest{magnitude: magnitude, direction: Direction::L, position: (j + (game.sizen * i))});
                        //             prev_active_r = 1;
                        //             }
                        //         } else {
                        //             prev_active_r = 2;
                        //         }
                        //         none_count_r = 0;
                        //     }
                        //     2 => {//Prior piece was non-active player, no right moves

                        //     }
                        // }


BROKEN ROW MOVE GENERATION BELOW; INDEXING ERRORS, UNCLEAR
for j in bound.0..bound.1 {
        if row[j as usize].is_none() && j != bound.1 - 1 {//If the last space is empty, we still have to generate some moves
            none_count_r += 1;
        } else {
            if row[j as usize].is_none() {none_count_r += 1;}//On last space, we may need an additional move available
            let is_my_piece = turn_parity == (row[j as usize] == Some(&Piece::Attacker));

            if none_count_r == 0 {prev_active_r = is_my_piece; continue} //Might save time; adjacent pieces cannot be moved

            if prev_active_r{
                //Add rightward moves from prior active player piece
                match contains_throne{
                    false => {//Standard Behavior 
                        for magnitude in 1..=none_count_r {
                        new_moves.push(MoveRequest{magnitude: magnitude, direction: Direction::R, position: (j - 1 - none_count_r + (sizen * index))});
                        }
                    }
                    true => {//When the throne is in the Col/Row, we must disallow any non-king piece to move into the throne
                        for magnitude in 1..=none_count_r {
                            if (j - none_count_r + magnitude) == throne_space{//Check if move moves into throne, allows only king to do so
                                if row[(j - none_count_r) as usize] == Some(&Piece::King){
                                    new_moves.push(MoveRequest{magnitude: magnitude, direction: Direction::R, position: (j - 1 - none_count_r + (sizen * index))});
                                } else {continue}
                            } else {
                                new_moves.push(MoveRequest{magnitude: magnitude, direction: Direction::R, position: (j - 1 - none_count_r + (sizen * index))});
                            }
                        }
                    }
                }
            }
            prev_active_r = is_my_piece; //Update what the "last" piece we've seen is with current view

            if is_my_piece {
                //Add leftward moves
                match contains_throne{
                    false => {//Default Behaviour
                        for magnitude in 1..=none_count_r {
                            new_moves.push(MoveRequest{magnitude: magnitude, direction: Direction::L, position: (j + (sizen * index))});
                        }
                    }
                    true => {
                        for magnitude in 1..=none_count_r{
                            if j - magnitude == throne_space {
                                if row[j as usize] == Some(&Piece::King){
                                    new_moves.push(MoveRequest{magnitude: magnitude, direction: Direction::L, position: (j + (sizen * index))});
                                } else {continue}
                            } else {
                                new_moves.push(MoveRequest{magnitude: magnitude, direction: Direction::L, position: (j + (sizen * index))});
                                }
                            }
                        }
                    }
                }
            }
        none_count_r = 0;
        }